# 비교 연산자

## 불린형 반환

다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환한다. 반환 값은 불린형이다.
* ```true```가 반환되면 긍정, 참, 사실을 의미
* ```false```가 반환되면 부정, 거짓, 사실이 아님을 의미

ex)

```
alert(2 > 1); // true
alert(2 == 1); // false
alert(2 != 1); // true
```

반환된 불린값은 다른 여타 값처럼 변수에 할당이 가능하다.
```
let result = 5 > 4; // 비교 결과를 변수에 할당
alert(result); // true
```

## 문자열 비교

자바스크립트는 '사전' 순으로 문자열을 비교한다. '사전편집'순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단된다.

ex)
```
alert('Z' > 'A'); // true
alert('Glow' > 'Glee'); // true
alert('Bee' > 'Be'); // true
```
문자열 비교 시 적용되는 알고리즘은 다음과 같다.

1. 두 문자열의 첫 글자를 비교한다
2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면) 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료한다.
3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
4. 글자 간 비교가 끝날 때까지 이 과정을 반복한다.
5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 낸다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.


❕ 정확히는 사전순이 아니라 유니코드 순이다.

## 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꾼다.

ex)

```
alert('2' > 1); // true, 문자열 '2'가 숫자 2로 변환된 후 비교 진행
alert('01' == 1); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행된다.
```
불린값의 경우 true는 1, false는 0으로 변환된 후 비교가 이루어진다.

ex)
```
alert( true == 1 ); // true
alert( false == 0); // false
```

❕ ### 흥미로운 상황

동시에 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있다.
* 동등 비교(==) 시 true 반환
* 논리 평가 시 값 하나는 true, 다른 값 하나는 false 반환

ex)
```
let a = 0;
alert(Boolean(a)); // false

let b = "0";
alert(Boolean(b)); // true

alert(a == b); // true
```

동등 비교 연산자 ```==```는 피연산자를 숫자형으로 바꾸지만, Boolean을 사용한 명시적 변환에는 다른 규칙이 사용되므로 참이 반환된다.

## 일치 연산자

동등 연산자 ```==```는 0과 false를 구별하지 못 한다.

```
alert(0 == false); // true
```

피연산자가 빈 문자열일 때도 같은 문제가 발생한다.

```
alert('' == false); // true
```

이런 문제는 동등 연산자 ```==```가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다.

그렇다면 0과 false를 구별할 수 있는 방법은 무엇이 있을까?

일치 연산자 ```===```를 사용하면 형 변환 없이 값을 비교할 수 있다.

일치 연산자는 엄격한 동등 연산자이다. 자료형의 동등 여부까지 검사하기 때문에 피연산자 a와 b의 형이 다를 경우 a === b 는 즉시 false를 반환한다.

```
alert(0 === false); // false, 피연산자의 형이 다르기 때문
```

## null 이나 undefined와 비교하기

null 이나 undefined를 다른 값과 비교할 땐 예상치 않은 일들이 발생한다.


일치 연산자 ===를 사용하여 nullrhk undefined를 비교하면 다음과 같다.
```
alert(null === undefined); // false
```
두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환된다.


동등 연산자 ==를 사용하여 null과 undefined를 비교하면 다음과 같다.
```
alert(null == undefined); // true
```

특별한 규칙이 적용되어 true가 반환된다.

### null vs 0

null과 0 을 비교하면 다음과 같다.
```
alert(null > 0); // false
alert(null == 0); // false
alert(null >= 0); // true
```
세번째에서 ```null >=0```이 참을 반환하는 이유는 null이 숫자형으로 변환되어 0이 되기 때문이다.

### 비교 불가능한 undefined

undefined를 다른 값과 비교해서는 안된다.
```
alert( undefined > 0 ); // false 
alert( undefined < 0 ); // false 
alert( undefined == 0 ); // false 
```
* 항상 false를 반환하고 있는데 첫번째와 두번째는 undefined가 NaN으로 변환되는데 , NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환한다.
* undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 세번째는 false를 반환한다.


### 함정 피하기

위와 같은 내용들을 꼭 암기할 필요는 없기 때문에 아래와 같은 방법을 통해 예외 상황을 미리 예방할 수 있다.

* 일치 연산자 ```===```를 제외한 비교 연산자의 피연산자에 undefined나 null 이 오지 않도록 특별히 주의한다.
* undefined나 null이 될 가능성 있는 변수가 <,>,<=,>=의 피연산자가 되지 않도록 주의해야한다. 만약 변수가 그럴 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하도록 한다.

